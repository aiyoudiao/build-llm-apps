# FAISS 向量数据库实践指南

本目录包含了使用 FAISS 进行向量存储和检索的示例代码，分为**基础版**（适合小规模数据）和**进阶版**（适合 10 亿级大规模数据）。

## 目录结构

- `1-embeding 计算.py`: 基础演示，调用 OpenAI/DashScope 接口生成 Embedding。
- `2-embedding-faiss-元数据.py`: 演示如何将文档转换为向量，并在内存中使用 FAISS 进行检索（包含元数据）。
- `3-save-to-faiss-持久化.py`: **[基础版]** 将向量索引和元数据保存到本地磁盘（`faiss_store/`）。
- `4-query-from-faiss-本地库.py`: **[基础版]** 从本地加载索引和元数据，进行查询。
- `5-save-to-faiss-模拟大数据.py`: **[进阶版]** 模拟 10 亿级数据的索引构建与保存（IVF-PQ）。
- `6-query-from-faiss-模拟大数据.py`: **[进阶版]** 模拟 10 亿级数据的快速加载与查询（mmap）。

---

## 1. 基础版：适合中小规模数据 (< 100万)

**特点**：
- 使用 `IndexFlatL2` 索引，暴力搜索，精度 100%。
- 索引文件较大，查询速度随数据量线性增长。
- 适合对精度要求高、数据量不大的场景。

**操作步骤**：
1.  **构建并保存索引**：
    ```bash
    python 3-save-to-faiss-持久化.py
    ```
    *   生成的索引文件：`faiss_store/faiss_index.bin`
    *   生成的元数据文件：`faiss_store/metadata.pkl`

2.  **加载并查询**：
    ```bash
    python 4-query-from-faiss-本地库.py
    ```

---

## 2. 进阶版：适合大规模数据 (10亿级 / 1B+)

**特点**：
- 使用 `IVF1024,PQ64` 索引（倒排 + 乘积量化）。
- **内存占用极低**：通过 PQ 压缩，将 4TB 内存需求降低到约 64GB。
- **查询速度极快**：通过 IVF 倒排，避免全量扫描。
- **启动秒开**：使用 `mmap` (内存映射) 方式加载索引，无需一次性读取大文件。

**关键参数**：
- `IVF1024`: 将数据空间划分为 1024 个聚类中心（倒排桶）。对于 10 亿数据，建议设为 65536 或更大。
- `PQ64`: 将 1024 维向量压缩为 64 字节。
- `nprobe`: 查询时搜索的桶数量，默认为 1，增加该值可提高召回率但会降低速度。

**操作步骤**：
1.  **构建并保存索引**（模拟生成）：
    ```bash
    python 5-save-to-faiss-模拟大数据.py
    ```
    *   生成的索引文件：`faiss_store_1b/faiss_index_ivf_pq.bin`

2.  **加载并查询**：
    ```bash
    python 6-query-from-faiss-模拟大数据.py
    ```

---

## 常见问题

### Q: `faiss_index.bin` 是什么？
A: 这是 FAISS 的索引文件，存储了向量数据及其结构（如倒排链、量化码书）。它是二进制文件，不能直接打开，必须用 `faiss.read_index` 加载。

### Q: `metadata.pkl` 是什么？
A: 这是 Python 的 `pickle` 序列化文件，用于存储文档的原始文本、ID、作者等元数据。FAISS 本身只存向量，不存这些信息，所以需要单独保存。

### Q: 为什么 10 亿数据不能用基础版？
A: 基础版 (`IndexFlatL2`) 会将所有向量完整加载到内存。10 亿条 1024 维 float32 向量需要约 **4TB 内存**，普通服务器无法通过 `read_index` 加载。进阶版通过 PQ 压缩和倒排索引解决了这个问题。
